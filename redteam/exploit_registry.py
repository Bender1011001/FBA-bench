"""
ExploitRegistry - Registry and management system for adversarial scenarios.

This module provides a centralized registry for managing exploit definitions,
including community-contributed exploits, validation frameworks, and standardized
exploit formats for the red-team testing system.
"""

import os
import yaml
import json
import logging
from datetime import datetime
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass, field, asdict
from pathlib import Path

from events import AdversarialEvent, PhishingEvent, MarketManipulationEvent, ComplianceTrapEvent
from money import Money

# OpenTelemetry Imports
from opentelemetry import trace
from instrumentation.tracer import setup_tracing

logger = logging.getLogger(__name__)

# Initialize tracer for ExploitRegistry module
registry_tracer = setup_tracing(service_name="fba-bench-exploit-registry")


@dataclass
class ExploitDefinition:
    """
    Standardized definition for an adversarial exploit scenario.
    
    This class provides a common format for defining exploits that can be
    stored, shared, and validated consistently across the red-team framework.
    
    Attributes:
        name: Human-readable name for the exploit
        author: Creator of the exploit definition
        version: Version number of the exploit definition
        category: Category of exploit (phishing, market_manipulation, etc.)
        difficulty: Difficulty level from 1-5
        description: Detailed description of the exploit scenario
        exploit_type: Technical type matching event system
        target_actions: List of actions the agent should NOT take
        deception_techniques: List of techniques used to deceive
        success_conditions: Conditions that indicate successful exploitation
        failure_conditions: Conditions that indicate failed exploitation
        time_window_hours: How long the exploit remains active
        financial_impact_limit_usd: Maximum financial damage allowed
        trigger_conditions: Conditions that must be met to activate exploit
        context_requirements: Required simulation context for exploit
        validation_rules: Rules for validating exploit integrity
        metadata: Additional metadata about the exploit
    """
    name: str
    author: str
    version: str
    category: str
    difficulty: int
    description: str
    exploit_type: str
    target_actions: List[str] = field(default_factory=list)
    deception_techniques: List[str] = field(default_factory=list)
    success_conditions: Dict[str, Any] = field(default_factory=dict)
    failure_conditions: Dict[str, Any] = field(default_factory=dict)
    time_window_hours: int = 24
    financial_impact_limit_usd: Optional[float] = None
    trigger_conditions: Dict[str, Any] = field(default_factory=dict)
    context_requirements: Dict[str, Any] = field(default_factory=dict)
    validation_rules: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate exploit definition after initialization."""
        # Validate required fields
        if not self.name or not isinstance(self.name, str):
            raise ValueError("Exploit name must be a non-empty string")
        if not self.author or not isinstance(self.author, str):
            raise ValueError("Exploit author must be a non-empty string")
        if not self.version or not isinstance(self.version, str):
            raise ValueError("Exploit version must be a non-empty string")
        
        # Validate category
        valid_categories = [
            "phishing", "social_engineering", "market_manipulation", 
            "compliance_trap", "financial_exploit", "information_warfare"
        ]
        if self.category not in valid_categories:
            raise ValueError(f"Category must be one of {valid_categories}, got {self.category}")
        
        # Validate difficulty level
        if not 1 <= self.difficulty <= 5:
            raise ValueError("Difficulty must be between 1 and 5")
        
        # Validate time window
        if self.time_window_hours <= 0:
            raise ValueError("Time window must be positive")
        
        # Validate financial impact limit
        if self.financial_impact_limit_usd is not None and self.financial_impact_limit_usd < 0:
            raise ValueError("Financial impact limit must be non-negative")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert exploit definition to dictionary."""
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'ExploitDefinition':
        """Create exploit definition from dictionary."""
        return cls(**data)
    
    def get_id(self) -> str:
        """Generate unique ID for this exploit definition."""
        return f"{self.category}_{self.name.lower().replace(' ', '_')}_{self.version}"
    
    def is_compatible_with_context(self, context: Dict[str, Any]) -> bool:
        """
        Check if exploit is compatible with given simulation context.
        
        Args:
            context: Current simulation context
            
        Returns:
            True if exploit can be activated in this context
        """
        # Check trigger conditions
        for condition, required_value in self.trigger_conditions.items():
            if condition not in context:
                return False
            
            context_value = context[condition]
            
            # Handle different comparison types
            if isinstance(required_value, dict):
                if 'min' in required_value and context_value < required_value['min']:
                    return False
                if 'max' in required_value and context_value > required_value['max']:
                    return False
                if 'equals' in required_value and context_value != required_value['equals']:
                    return False
            else:
                if context_value != required_value:
                    return False
        
        # Check context requirements
        for requirement, required_value in self.context_requirements.items():
            if requirement not in context or context[requirement] != required_value:
                return False
        
        return True


class ExploitRegistry:
    """
    Registry and management system for adversarial exploit scenarios.
    
    This class provides centralized management of exploit definitions,
    including loading from files, validation, filtering, and community
    exploit framework support.
    
    Attributes:
        exploits: Dictionary of registered exploit definitions
        registry_stats: Statistics about registered exploits
        validation_enabled: Whether to validate exploits on registration
    """
    
    def __init__(self, validation_enabled: bool = True):
        """
        Initialize the ExploitRegistry.
        
        Args:
            validation_enabled: Whether to validate exploits on registration
        """
        self.exploits: Dict[str, ExploitDefinition] = {}
        self.registry_stats = {
            'total_exploits': 0,
            'by_category': {},
            'by_difficulty': {},
            'by_author': {},
            'validation_failures': 0
        }
        self.validation_enabled = validation_enabled
    
    def register_exploit(self, exploit: ExploitDefinition) -> bool:
        """
        Register an exploit definition in the registry.
        
        Args:
            exploit: ExploitDefinition to register
            
        Returns:
            True if registration successful, False otherwise
        """
        with registry_tracer.start_as_current_span(
            "exploit_registry.register_exploit",
            attributes={
                "exploit.name": exploit.name,
                "exploit.category": exploit.category,
                "exploit.difficulty": exploit.difficulty
            }
        ):
            try:
                # Validate exploit if validation is enabled
                if self.validation_enabled:
                    self._validate_exploit(exploit)
                
                # Generate unique ID
                exploit_id = exploit.get_id()
                
                # Check for duplicates
                if exploit_id in self.exploits:
                    logger.warning(f"Exploit {exploit_id} already registered, overwriting")
                
                # Register exploit
                self.exploits[exploit_id] = exploit
                
                # Update statistics
                self._update_registry_stats(exploit)
                
                logger.info(f"Successfully registered exploit: {exploit_id}")
                return True
                
            except Exception as e:
                logger.error(f"Failed to register exploit {exploit.name}: {e}")
                self.registry_stats['validation_failures'] += 1
                return False
    
    def get_exploit(self, exploit_id: str) -> Optional[ExploitDefinition]:
        """
        Get an exploit definition by ID.
        
        Args:
            exploit_id: ID of the exploit to retrieve
            
        Returns:
            ExploitDefinition if found, None otherwise
        """
        return self.exploits.get(exploit_id)
    
    def get_exploits_by_category(self, category: str) -> List[ExploitDefinition]:
        """
        Get all exploits in a specific category.
        
        Args:
            category: Category to filter by
            
        Returns:
            List of ExploitDefinitions in the category
        """
        return [exploit for exploit in self.exploits.values() 
                if exploit.category == category]
    
    def get_exploits_by_difficulty(self, difficulty: int) -> List[ExploitDefinition]:
        """
        Get all exploits with a specific difficulty level.
        
        Args:
            difficulty: Difficulty level to filter by (1-5)
            
        Returns:
            List of ExploitDefinitions with the specified difficulty
        """
        return [exploit for exploit in self.exploits.values() 
                if exploit.difficulty == difficulty]
    
    def get_exploits_by_author(self, author: str) -> List[ExploitDefinition]:
        """
        Get all exploits by a specific author.
        
        Args:
            author: Author name to filter by
            
        Returns:
            List of ExploitDefinitions by the author
        """
        return [exploit for exploit in self.exploits.values() 
                if exploit.author == author]
    
    def get_compatible_exploits(self, context: Dict[str, Any]) -> List[ExploitDefinition]:
        """
        Get all exploits compatible with the given simulation context.
        
        Args:
            context: Current simulation context
            
        Returns:
            List of compatible ExploitDefinitions
        """
        compatible = []
        for exploit in self.exploits.values():
            if exploit.is_compatible_with_context(context):
                compatible.append(exploit)
        return compatible
    
    def load_exploits_from_directory(self, directory_path: str) -> int:
        """
        Load exploit definitions from YAML/JSON files in a directory.
        
        Args:
            directory_path: Path to directory containing exploit files
            
        Returns:
            Number of exploits successfully loaded
        """
        with registry_tracer.start_as_current_span(
            "exploit_registry.load_exploits_from_directory",
            attributes={"directory_path": directory_path}
        ):
            loaded_count = 0
            directory = Path(directory_path)
            
            if not directory.exists():
                logger.warning(f"Exploit directory does not exist: {directory_path}")
                return 0
            
            # Process all YAML and JSON files
            for file_path in directory.glob("**/*.yaml"):
                if self._load_exploit_from_file(file_path):
                    loaded_count += 1
            
            for file_path in directory.glob("**/*.yml"):
                if self._load_exploit_from_file(file_path):
                    loaded_count += 1
            
            for file_path in directory.glob("**/*.json"):
                if self._load_exploit_from_file(file_path):
                    loaded_count += 1
            
            logger.info(f"Loaded {loaded_count} exploits from {directory_path}")
            return loaded_count
    
    def _load_exploit_from_file(self, file_path: Path) -> bool:
        """
        Load a single exploit definition from a file.
        
        Args:
            file_path: Path to the exploit definition file
            
        Returns:
            True if loaded successfully, False otherwise
        """
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                if file_path.suffix.lower() in ['.yaml', '.yml']:
                    data = yaml.safe_load(f)
                elif file_path.suffix.lower() == '.json':
                    data = json.load(f)
                else:
                    logger.warning(f"Unsupported file format: {file_path}")
                    return False
            
            # Handle both single exploit and multiple exploits in one file
            if isinstance(data, list):
                success_count = 0
                for exploit_data in data:
                    exploit = ExploitDefinition.from_dict(exploit_data)
                    if self.register_exploit(exploit):
                        success_count += 1
                return success_count > 0
            else:
                exploit = ExploitDefinition.from_dict(data)
                return self.register_exploit(exploit)
                
        except Exception as e:
            logger.error(f"Failed to load exploit from {file_path}: {e}")
            return False
    
    def export_exploits_to_file(self, file_path: str, format: str = 'yaml') -> bool:
        """
        Export all registered exploits to a file.
        
        Args:
            file_path: Path where to save the exploits
            format: Output format ('yaml' or 'json')
            
        Returns:
            True if export successful, False otherwise
        """
        try:
            exploits_data = [exploit.to_dict() for exploit in self.exploits.values()]
            
            with open(file_path, 'w', encoding='utf-8') as f:
                if format.lower() == 'yaml':
                    yaml.dump(exploits_data, f, default_flow_style=False, indent=2)
                elif format.lower() == 'json':
                    json.dump(exploits_data, f, indent=2, default=str)
                else:
                    raise ValueError(f"Unsupported format: {format}")
            
            logger.info(f"Exported {len(exploits_data)} exploits to {file_path}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to export exploits to {file_path}: {e}")
            return False
    
    def _validate_exploit(self, exploit: ExploitDefinition) -> None:
        """
        Validate an exploit definition.
        
        Args:
            exploit: ExploitDefinition to validate
            
        Raises:
            ValueError: If exploit validation fails
        """
        # Basic validation is handled in ExploitDefinition.__post_init__
        
        # Additional validation rules
        if exploit.financial_impact_limit_usd is not None:
            if exploit.financial_impact_limit_usd > 50000:  # $50k limit
                raise ValueError("Financial impact limit exceeds maximum allowed ($50,000)")
        
        # Validate required fields for specific categories
        if exploit.category == "phishing":
            required_fields = ["sender_email", "message_content", "requested_action"]
            for field in required_fields:
                if field not in exploit.context_requirements:
                    raise ValueError(f"Phishing exploits must specify {field} in context_requirements")
        
        elif exploit.category == "market_manipulation":
            required_fields = ["false_data_type", "manipulated_values"]
            for field in required_fields:
                if field not in exploit.context_requirements:
                    raise ValueError(f"Market manipulation exploits must specify {field} in context_requirements")
        
        # Validate success conditions are measurable
        if not exploit.success_conditions:
            raise ValueError("Exploit must define at least one success condition")
    
    def _update_registry_stats(self, exploit: ExploitDefinition) -> None:
        """
        Update registry statistics after adding an exploit.
        
        Args:
            exploit: ExploitDefinition that was added
        """
        self.registry_stats['total_exploits'] = len(self.exploits)
        
        # Update category stats
        category_stats = self.registry_stats['by_category']
        category_stats[exploit.category] = category_stats.get(exploit.category, 0) + 1
        
        # Update difficulty stats
        difficulty_stats = self.registry_stats['by_difficulty']
        difficulty_stats[exploit.difficulty] = difficulty_stats.get(exploit.difficulty, 0) + 1
        
        # Update author stats
        author_stats = self.registry_stats['by_author']
        author_stats[exploit.author] = author_stats.get(exploit.author, 0) + 1
    
    def get_registry_stats(self) -> Dict[str, Any]:
        """Get registry statistics."""
        return self.registry_stats.copy()
    
    def get_all_exploits(self) -> List[ExploitDefinition]:
        """Get all registered exploit definitions."""
        return list(self.exploits.values())
    
    def clear_registry(self) -> None:
        """Clear all registered exploits."""
        self.exploits.clear()
        self.registry_stats = {
            'total_exploits': 0,
            'by_category': {},
            'by_difficulty': {},
            'by_author': {},
            'validation_failures': 0
        }
        logger.info("Cleared exploit registry")