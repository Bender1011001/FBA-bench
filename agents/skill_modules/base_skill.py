"""
Base Skill Module for FBA-Bench Multi-Domain Agent Architecture.

This module defines the abstract base class for all specialized skill modules,
providing a unified interface for event-driven decision making and action generation
across different business domains.
"""

import asyncio
import logging
import uuid
from abc import ABC, abstractmethod
from datetime import datetime
from typing import Dict, Any, List, Optional, Set, Union
from dataclasses import dataclass, field
from enum import Enum

from events import BaseEvent
from event_bus import EventBus

logger = logging.getLogger(__name__)


class SkillStatus(Enum):
    """Status values for skill operational state."""
    ACTIVE = "active"
    IDLE = "idle"
    PROCESSING = "processing"
    ERROR = "error"
    DISABLED = "disabled"


@dataclass
class SkillAction:
    """
    Represents an action generated by a skill module.
    
    Attributes:
        action_type: Type of action (e.g., "set_price", "place_order", "run_campaign")
        parameters: Parameters for the action
        confidence: Confidence score for the action (0.0 to 1.0)
        reasoning: Explanation for why this action was generated
        priority: Priority level for execution (higher = more urgent)
        resource_requirements: Required resources (budget, tokens, etc.)
        expected_outcome: Predicted outcome of the action
        skill_source: Which skill generated this action
    """
    action_type: str
    parameters: Dict[str, Any]
    confidence: float
    reasoning: str
    priority: float = 0.5
    resource_requirements: Dict[str, Any] = field(default_factory=dict)
    expected_outcome: Dict[str, Any] = field(default_factory=dict)
    skill_source: str = ""
    
    def __post_init__(self):
        """Validate skill action data."""
        if not self.action_type:
            raise ValueError("Action type cannot be empty")
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")
        if not 0.0 <= self.priority <= 1.0:
            raise ValueError("Priority must be between 0.0 and 1.0")


@dataclass
class SkillContext:
    """
    Context information provided to skills for decision making.
    
    Attributes:
        agent_id: ID of the agent this skill belongs to
        current_tick: Current simulation tick
        timestamp: Current timestamp
        agent_state: Current state of the agent
        market_data: Current market conditions
        financial_state: Current financial position
        constraints: Active constraints and limits
        performance_metrics: Recent performance data
    """
    agent_id: str
    current_tick: int
    timestamp: datetime
    agent_state: Dict[str, Any] = field(default_factory=dict)
    market_data: Dict[str, Any] = field(default_factory=dict)
    financial_state: Dict[str, Any] = field(default_factory=dict)
    constraints: Dict[str, Any] = field(default_factory=dict)
    performance_metrics: Dict[str, float] = field(default_factory=dict)


@dataclass
class SkillOutcome:
    """
    Outcome of a skill action for learning and adaptation.
    
    Attributes:
        action_id: ID of the action that was executed
        success: Whether the action was successful
        impact_metrics: Measured impact of the action
        execution_time: How long the action took to execute
        resource_cost: Actual resources consumed
        lessons_learned: Insights for future decision making
        confidence_validation: How actual outcome compared to expected
    """
    action_id: str
    success: bool
    impact_metrics: Dict[str, float] = field(default_factory=dict)
    execution_time: float = 0.0
    resource_cost: Dict[str, Any] = field(default_factory=dict)
    lessons_learned: List[str] = field(default_factory=list)
    confidence_validation: float = 0.0


class BaseSkill(ABC):
    """
    Abstract base class for all specialized skill modules.
    
    Provides the foundation for event-driven, domain-specific decision making
    with learning capabilities and resource awareness.
    """
    
    def __init__(self, skill_name: str, agent_id: str, event_bus: EventBus):
        """
        Initialize the base skill.
        
        Args:
            skill_name: Unique name for this skill type
            agent_id: ID of the agent this skill belongs to
            event_bus: Event bus for communication
        """
        self.skill_name = skill_name
        self.agent_id = agent_id
        self.event_bus = event_bus
        
        # Skill state tracking
        self.status = SkillStatus.IDLE
        self.last_activation = None
        self.activation_count = 0
        self.error_count = 0
        
        # Performance tracking
        self.success_rate = 0.5
        self.average_confidence = 0.0
        self.response_time = 0.0
        self.resource_efficiency = 1.0
        
        # Learning and adaptation
        self.historical_outcomes: List[SkillOutcome] = []
        self.learned_patterns: Dict[str, Any] = {}
        self.adaptation_parameters: Dict[str, float] = {}
        
        # Event subscriptions
        self.subscribed_events: Set[str] = set()
        
        logger.info(f"Initialized {skill_name} skill for agent {agent_id}")
    
    @abstractmethod
    async def process_event(self, event: BaseEvent) -> Optional[List[SkillAction]]:
        """
        Process a relevant event and generate appropriate actions.
        
        Args:
            event: The event to process
            
        Returns:
            List of actions to take, or None if no actions needed
        """
        pass
    
    @abstractmethod
    async def generate_actions(self, context: SkillContext, constraints: Dict[str, Any]) -> List[SkillAction]:
        """
        Generate domain-specific actions based on current context and constraints.
        
        Args:
            context: Current context information for decision making
            constraints: Active constraints and limits
            
        Returns:
            List of actions this skill recommends
        """
        pass
    
    @abstractmethod
    def get_priority_score(self, event: BaseEvent) -> float:
        """
        Calculate priority score for an event (0.0 to 1.0).
        
        Args:
            event: Event to evaluate
            
        Returns:
            Priority score indicating urgency/importance
        """
        pass
    
    def get_skill_status(self) -> Dict[str, Any]:
        """
        Get current operational status of the skill.
        
        Returns:
            Dictionary containing skill status information
        """
        return {
            'skill_name': self.skill_name,
            'agent_id': self.agent_id,
            'status': self.status.value,
            'last_activation': self.last_activation.isoformat() if self.last_activation else None,
            'activation_count': self.activation_count,
            'error_count': self.error_count,
            'success_rate': round(self.success_rate, 3),
            'average_confidence': round(self.average_confidence, 3),
            'response_time': round(self.response_time, 3),
            'resource_efficiency': round(self.resource_efficiency, 3),
            'subscribed_events': list(self.subscribed_events),
            'learned_patterns_count': len(self.learned_patterns)
        }
    
    def update_skill_state(self, outcome: SkillOutcome) -> None:
        """
        Update skill state based on action outcome for learning and adaptation.
        
        Args:
            outcome: Outcome of a skill action
        """
        try:
            # Store historical outcome
            self.historical_outcomes.append(outcome)
            
            # Limit history size to prevent memory bloat
            if len(self.historical_outcomes) > 100:
                self.historical_outcomes.pop(0)
            
            # Update performance metrics
            self._update_performance_metrics(outcome)
            
            # Learn from the outcome
            self._learn_from_outcome(outcome)
            
            # Adapt parameters based on recent performance
            self._adapt_parameters()
            
            logger.debug(f"Updated {self.skill_name} skill state based on outcome: success={outcome.success}")
            
        except Exception as e:
            logger.error(f"Error updating skill state for {self.skill_name}: {e}")
            self.error_count += 1
    
    async def subscribe_to_events(self, event_types: List[str]) -> None:
        """
        Subscribe to relevant event types for this skill.
        
        Args:
            event_types: List of event type names to subscribe to
        """
        for event_type in event_types:
            try:
                await self.event_bus.subscribe(event_type, self._handle_event)
                self.subscribed_events.add(event_type)
                logger.debug(f"{self.skill_name} skill subscribed to {event_type}")
            except Exception as e:
                logger.error(f"Failed to subscribe {self.skill_name} to {event_type}: {e}")
    
    async def _handle_event(self, event: BaseEvent) -> None:
        """
        Internal event handler that wraps process_event with status tracking.
        
        Args:
            event: Event received from event bus
        """
        try:
            self.status = SkillStatus.PROCESSING
            self.last_activation = datetime.now()
            self.activation_count += 1
            
            start_time = datetime.now()
            actions = await self.process_event(event)
            end_time = datetime.now()
            
            # Update response time
            processing_time = (end_time - start_time).total_seconds()
            self.response_time = (self.response_time * 0.8) + (processing_time * 0.2)  # EMA
            
            self.status = SkillStatus.ACTIVE if actions else SkillStatus.IDLE
            
            # If actions were generated, they'll be handled by the coordinator
            if actions:
                logger.debug(f"{self.skill_name} generated {len(actions)} actions for event {type(event).__name__}")
                
        except Exception as e:
            logger.error(f"Error in {self.skill_name} event handling: {e}")
            self.status = SkillStatus.ERROR
            self.error_count += 1
    
    def _update_performance_metrics(self, outcome: SkillOutcome) -> None:
        """Update performance metrics based on outcome."""
        # Update success rate using exponential moving average
        self.success_rate = (self.success_rate * 0.9) + (float(outcome.success) * 0.1)
        
        # Update confidence validation
        if outcome.confidence_validation > 0:
            self.average_confidence = (self.average_confidence * 0.9) + (outcome.confidence_validation * 0.1)
        
        # Update resource efficiency
        if outcome.resource_cost and outcome.impact_metrics:
            # Simple efficiency calculation - can be overridden by subclasses
            cost_sum = sum(v for v in outcome.resource_cost.values() if isinstance(v, (int, float)))
            impact_sum = sum(v for v in outcome.impact_metrics.values() if isinstance(v, (int, float)))
            if cost_sum > 0:
                efficiency = max(0.1, min(2.0, impact_sum / cost_sum))
                self.resource_efficiency = (self.resource_efficiency * 0.9) + (efficiency * 0.1)
    
    def _learn_from_outcome(self, outcome: SkillOutcome) -> None:
        """Learn patterns from action outcomes."""
        # Extract patterns from successful actions
        if outcome.success and outcome.lessons_learned:
            for lesson in outcome.lessons_learned:
                pattern_key = f"success_pattern_{len(self.learned_patterns)}"
                self.learned_patterns[pattern_key] = {
                    'lesson': lesson,
                    'confidence': outcome.confidence_validation,
                    'timestamp': datetime.now().isoformat()
                }
        
        # Learn from failures too
        elif not outcome.success and outcome.lessons_learned:
            for lesson in outcome.lessons_learned:
                pattern_key = f"failure_pattern_{len(self.learned_patterns)}"
                self.learned_patterns[pattern_key] = {
                    'lesson': lesson,
                    'avoid': True,
                    'timestamp': datetime.now().isoformat()
                }
    
    def _adapt_parameters(self) -> None:
        """Adapt skill parameters based on recent performance."""
        if len(self.historical_outcomes) < 5:
            return  # Need sufficient data for adaptation
        
        recent_outcomes = self.historical_outcomes[-10:]  # Last 10 outcomes
        recent_success_rate = sum(1 for outcome in recent_outcomes if outcome.success) / len(recent_outcomes)
        
        # Adapt confidence threshold based on recent performance
        if recent_success_rate > 0.8:
            # High success rate - can be more aggressive
            self.adaptation_parameters['confidence_threshold'] = max(0.4, 
                self.adaptation_parameters.get('confidence_threshold', 0.6) * 0.95)
        elif recent_success_rate < 0.4:
            # Low success rate - be more conservative
            self.adaptation_parameters['confidence_threshold'] = min(0.9,
                self.adaptation_parameters.get('confidence_threshold', 0.6) * 1.05)
    
    def get_learned_insights(self) -> List[str]:
        """Get insights learned by this skill."""
        insights = []
        for pattern in self.learned_patterns.values():
            if isinstance(pattern, dict) and 'lesson' in pattern:
                insights.append(pattern['lesson'])
        return insights
    
    def reset_skill_state(self) -> None:
        """Reset skill state for testing or reinitialization."""
        self.status = SkillStatus.IDLE
        self.last_activation = None
        self.activation_count = 0
        self.error_count = 0
        self.historical_outcomes.clear()
        self.learned_patterns.clear()
        self.adaptation_parameters.clear()
        
        logger.info(f"Reset state for {self.skill_name} skill")