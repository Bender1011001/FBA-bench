from __future__ import annotations

"""
Multi-Turn Tool Use Scenario

Requires tool-like steps (calculator, extract, transform) applied in sequence; deterministic via seed.

Public interface exposed by this module:
- [python.class MultiTurnToolUseConfig(BaseModel)](benchmarking/scenarios/multiturn_tool_use.py:1)
- [python.def generate_input(seed: int|None, params: dict|None) -> dict](benchmarking/scenarios/multiturn_tool_use.py:1)
- [python.async def run(input_payload: dict, runner_callable: Callable[[dict], Awaitable[dict]], timeout_seconds: int|None=None) -> dict](benchmarking/scenarios/multiturn_tool_use.py:1)

Registration:
- Registers itself under key "multiturn_tool_use" via the global ScenarioRegistry.
"""

import operator
import random
from dataclasses import dataclass
from typing import Any, Awaitable, Callable, Dict, List, Optional, Tuple

from pydantic import BaseModel, Field, ValidationError

from .registry import scenario_registry


def _rnd(seed: Optional[int]) -> random.Random:
    r = random.Random()
    if seed is not None:
        r.seed(seed)
    return r


OPS = [
    ("+", operator.add),
    ("-", operator.sub),
    ("*", operator.mul),
]


def _gen_math_expr(r: random.Random) -> Tuple[str, int]:
    a = r.randint(2, 20)
    b = r.randint(2, 20)
    sym, fn = r.choice(OPS)
    expr = f"{a} {sym} {b}"
    return expr, int(fn(a, b))


EXTRACT_FIELDS = ["name", "date", "amount", "account", "invoice", "region"]


def _gen_extraction_text(r: random.Random) -> Tuple[str, Dict[str, str]]:
    # Generate a deterministic paragraph containing certain key: value pairs.
    values = {
        "name": f"User{r.randint(100,999)}",
        "date": f"202{r.randint(0,4)}-{r.randint(1,12):02d}-{r.randint(1,28):02d}",
        "amount": f"{r.randint(10,500)}.{r.randint(0,99):02d}",
        "account": f"ACCT-{r.randint(10000,99999)}",
        "invoice": f"INV-{r.randint(1000,9999)}",
        "region": r.choice(["NA", "EU", "APAC", "LATAM"]),
    }
    sentence = (
        f"On {values['date']}, {values['name']} paid ${values['amount']} "
        f"for invoice {values['invoice']} from account {values['account']} in {values['region']}."
    )
    filler = " This record is autogenerated for audit. "
    text = sentence + filler * 2
    return text, values


def _gen_transform(r: random.Random) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    data = {
        "items": [r.randint(1, 9) for _ in range(r.randint(3, 6))],
        "multiplier": r.randint(2, 5),
        "offset": r.randint(-3, 3),
    }
    expected = {
        "sum": sum(data["items"]),
        "transformed": [i * data["multiplier"] + data["offset"] for i in data["items"]],
    }
    return data, expected


class MultiTurnToolUseConfig(BaseModel):
    """
    Configuration schema (Pydantic v2) for Multi-Turn Tool Use Scenario.
    """

    steps: int = Field(3, ge=1, le=3, description="Number of tool steps required (max 3)")
    include_math: bool = Field(True, description="Include calculator step")
    include_extraction: bool = Field(True, description="Include field extraction step")
    include_transform: bool = Field(False, description="Include data transform step")

    model_config = {
        "json_schema_extra": {
            "examples": [
                {"steps": 3, "include_math": True, "include_extraction": True, "include_transform": True},
                {"steps": 2, "include_math": True, "include_extraction": False, "include_transform": True},
            ]
        }
    }


def generate_input(seed: Optional[int] = None, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
    """
    Deterministically emit a sequence of tool-like tasks derived from seed; expected outputs known deterministically.
    """
    params = params or {}
    try:
        cfg = MultiTurnToolUseConfig(**params)
    except ValidationError as e:
        raise ValueError(str(e)) from e

    r = _rnd(seed)

    tasks: List[Dict[str, Any]] = []
    expected: List[Dict[str, Any]] = []

    # Determine which steps to include, respecting 'steps' count and include_* flags
    step_order = []
    if cfg.include_math:
        step_order.append("math")
    if cfg.include_extraction:
        step_order.append("extraction")
    if cfg.include_transform:
        step_order.append("transform")
    # Limit to cfg.steps
    step_order = step_order[: cfg.steps]

    for step in step_order:
        if step == "math":
            expr, result = _gen_math_expr(r)
            tasks.append({"type": "math", "expression": expr})
            expected.append({"type": "math", "result": result})
        elif step == "extraction":
            text, fields = _gen_extraction_text(r)
            tasks.append({"type": "extraction", "text": text, "fields": EXTRACT_FIELDS})
            expected.append({"type": "extraction", "result": fields})
        elif step == "transform":
            data, exp = _gen_transform(r)
            tasks.append({"type": "transform", "data": data})
            expected.append({"type": "transform", "result": exp})

    return {
        "config": cfg.model_dump(),
        "seed": seed,
        "steps": step_order,
        "tasks": tasks,
        "expected": expected,  # used to score correctness
        "instructions": (
            "Perform each step in order. For math, compute the numeric result. "
            "For extraction, return a dict containing the requested fields exactly as present. "
            "For transform, return {'sum': int, 'transformed': list[int]} as specified."
        ),
    }


async def run(
    input_payload: Dict[str, Any],
    runner_callable: Callable[[Dict[str, Any]], Awaitable[Dict[str, Any]]],
    timeout_seconds: Optional[int] = None,
) -> Dict[str, Any]:
    """
    Execute the scenario: provide the tasks; evaluate runner output against deterministic expectations.

    Runner contract:
    - Input: {"tasks": list[...], "instructions": str, "seed": int|None}
    - Expected output: {"results": list[dict]} in same order as tasks
    """
    runner_input = {
        "tasks": input_payload.get("tasks", []),
        "instructions": input_payload.get("instructions"),
        "seed": input_payload.get("seed"),
    }
    expected = list(input_payload.get("expected", []))
    steps = list(input_payload.get("steps", []))

    raw = await runner_callable(runner_input)

    results: List[Dict[str, Any]] = list(raw.get("results", []))
    total = len(expected)
    correct = 0

    # Compare result-by-result
    for i in range(min(len(results), total)):
        exp = expected[i]
        got = results[i] or {}
        stype = exp.get("type")
        if stype == "math":
            if int(got.get("result", -999999)) == int(exp["result"]):
                correct += 1
        elif stype == "extraction":
            # Strict subset correctness: all expected key/value pairs must match exactly
            got_res = got.get("result", {})
            if isinstance(got_res, dict) and all(str(got_res.get(k)) == str(exp["result"][k]) for k in exp["result"].keys()):
                correct += 1
        elif stype == "transform":
            got_res = got.get("result", {})
            ok = isinstance(got_res, dict)
            ok = ok and int(got_res.get("sum", -1)) == int(exp["result"]["sum"])
            ok = ok and list(got_res.get("transformed", [])) == list(exp["result"]["transformed"])
            if ok:
                correct += 1

    steps_completed = min(len(results), total)
    score = 0.0 if total == 0 else round(correct / total, 4)

    return {
        "steps_completed": int(steps_completed),
        "correct": int(correct),
        "total": int(total),
        "score": float(score),
        "details": {"steps": steps},
    }


# Register with the scenario registry
@dataclass
class MultiTurnToolUseScenarioAdapter:
    Config = MultiTurnToolUseConfig

    @staticmethod
    def generate_input(seed: Optional[int] = None, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        return generate_input(seed=seed, params=params)

    @staticmethod
    async def run(
        input_payload: Dict[str, Any],
        runner_callable: Callable[[Dict[str, Any]], Awaitable[Dict[str, Any]]],
        timeout_seconds: Optional[int] = None,
    ) -> Dict[str, Any]:
        return await globals()["run"](input_payload, runner_callable, timeout_seconds)


scenario_registry.register("multiturn_tool_use", MultiTurnToolUseScenarioAdapter)